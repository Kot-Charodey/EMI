using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EMI.DebugLog
{
    /// <summary>
    /// Сообщения для вывода в логи
    /// </summary>
    internal static class Messages
    {
        public static LogMessage InitClientSide = LogMessage.Create(LogType.Message, "Client => init on client side (service: {0})");
        public static LogMessage InitServerSide = LogMessage.Create(LogType.Message, "Client => init on server side (service: {0})");
        public static LogMessage ConnectBeding = LogMessage.Create(LogType.Message, "Client => connect begin (IsConnect = {0}; IsServerSide = {1})");
        public static LogMessage ConnectStatus = LogMessage.Create(LogType.Message, "Client => INetworkClient.Сonnect() return status => {0}");

        public static LogMessage ConnectCanceled = LogMessage.Create(LogType.Message, "Client => connection operation was canceled");
        public static LogMessage ConnectDone = LogMessage.Create(LogType.Message, "Client => connect done!");
        public static LogMessage ConnectUnsuccessful = LogMessage.Create(LogType.Message, "Client => connect unsuccessful!");
        public static LogMessage ClientDisconnect = LogMessage.Create(LogType.Message, "Client => Client disconnect => message: {0}");
        public static LogMessage AlreadyRunning = LogMessage.Create(LogType.CriticalError, "Сlient is already running!");

        public static LogMessage PossibleReconnect = LogMessage.Create(LogType.CriticalError, "It is not possible to reconnect the client generated by the server!");
        public static LogMessage AlreadyDisconnected = LogMessage.Create(LogType.Error, "Client => client is already disconnected!");
        public static LogMessage LowDisconnectError = LogMessage.Create(LogType.CriticalError, "Client => LowDisconnect => error: {0}");
        public static LogMessage DoCanellationError = LogMessage.Create(LogType.Error, "Client => DoCancellationRun => throw error: {0}");

        public static LogMessage PingTimeout = LogMessage.Create(LogType.CriticalError, "Client => ProccesPing => timeout ({0} ms)");
        public static LogMessage PingError = LogMessage.Create(LogType.CriticalError, "Client => ProccesPing => error: {0}");
        public static LogMessage PingStoped = LogMessage.Create(LogType.Message, "Client => ProccesPing => stoped");
        public static LogMessage AcceptPacketError = LogMessage.Create(LogType.CriticalError, "Client => ProcessAccept => packet accept => throw error: {0}");

        public static LogMessage AcceptStoped = LogMessage.Create(LogType.Message, "Client => ProcessAccept => stoped");
        public static LogMessage RPCReturnNotFound = LogMessage.Create(LogType.Message, "Client => ProcessAccept => RPCReturn.TryGetValue => not found, timeout");
        public static LogMessage BadPacketTypeForwarding = LogMessage.Create(LogType.CriticalError, "Client => ProcessAccept => bad packet type (forwarding not supported on clients)");
        public static LogMessage NotFoundForwarding = LogMessage.Create(LogType.Error, "Client => EMI RC => not found forwarding!");

        public static LogMessage BadPacketType = LogMessage.Create(LogType.Message, "Client => ProcessAccept => bad packet type");
        public static LogMessage RPCNotFount = LogMessage.Create(LogType.Waring, "Client => EMI RC => Not found method! [{0}]");
        public static LogMessage AcceptStart = LogMessage.Create(LogType.Message, "Client => ProcessAccept => start");
        public static LogMessage PingStart = LogMessage.Create(LogType.Message, "Client => ProccesPing => start");
    }
}
